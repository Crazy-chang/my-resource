### 1、设计模式

设计模式是一种可服用的解决方案，用于解决项目所在的环境及场景中遇到的常见问题，不断重复发生的问题，以及该问题的核心解决方案

设计模式的核心操作是去观察你整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。



**为什么前端需要了解设计模式**

使用设计模式是为了**可复用代码、让代码更容易被他人理解、保证代码可靠性**和稳定性。设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石。

在日常开发中大部分前端都在进行组件、方法等封装、提炼的时候或多或少已经使用了一些设计模式的理念， 但是由于对设计模式的概念模糊，理解不够，从而导致设计整体架构的时候，会有各种**局限性，拓展性、可读性、维护性变差**，不得不多次重构甚至重写。



### 2、面向对象编程（OOP）：

**Object Oriented Programming**：简单来讲，面向对象编程就是将需求抽象成一个对象，然后为其添加特定的属性和行为方法，我们将这个对象称之为类。

面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

特点：复用性、灵活性、扩展性

面向对象的核心概念就是「类」和「对象」，其中拥有「封装」、「继承」、「多态」的特性。这些特性在面向对象编程中起着非常关键的作用。



//类的实例就是对象； 这是一个Person类
// 对人的抽象，定义了人的特性，例如名字，年龄，身高，体重等等的数据形式，也定义了人的行为，例如说话，跑步等等

```
class Person {
  name: string;
  age: number;
  height: number;
  weight: number;
  ...

  talk(){
    console.log('speak english');
  }
  run(){}
  ...
}

// keven 是一个对象，他是一个具体的人，他包含名字，年龄，身高...，也可以说话，跑步...
const keven:Person = new Person();
```



**封装：**将属性和方法组成一个抽象类的过程，内部实现细节对外部隐藏，使用属性描述符来控制成员的访问

```
class Person {

  private assets: number; // 他有很多钱，除了他自己，并不想让任何人（包含自己的家人）知道
  protected houseKey: string; // 这个人不想让外人知道自己家的钥匙，除非是自己的家人，例如他的儿子
  public name: string; // 他的名字任何人都可以知道

}
```



**继承：**子类继承了父类的特性和行为，并且对这些特性和行为进行扩展。

继承包括：原型链继承、原型式继承、构造函数继承、组合继承、寄生式继承、寄生组合继承

```
// YellowPerson 继承了 Person，则继承了 Person 的特性和行为
// 虽然 YellowPerson 内部未声明任何属性和方法，但它已经具有 name，age，height...

class YellowPerson extends Person {
  playTableTennis() {}
}
```



**多态：**子类重写父类，继承同一个父类的子类对同一个特性或行为会表现得不同

```
// 子类继承了父类，但子类对同一个特性 talk 表现的不同，例如可以说中文，可以说非洲语
class YellowPerson extends Person {
  talk() {
    console.log('说中文');
  }
}

class BlackPerson extends Person {
  talk() {
    console.log('说非洲语');
  }
}
```





### 3、工程化；

至今都没有一个标准说法。

工程化的理解：大概就是一切提升开发效率的，降低开发成本及难度，提高前端应用质量的手段和工具的方式都是前端工程化。

前端工程化可以分成四个方面来说，分别为`模块化`、`组件化`、`规范化`和`自动化`。

好处：提升开发效率；提高代码清晰简洁度；提高代码质量；提高可维护性；降低开发难度；降低成本等等



#### 3.1、模块化

模块化是指将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作。其中包含

JS 模块化：CommonJS、AMD、CMD 以及 ES6 Module。
CSS 模块化：Sass、Less、Stylus、BEM、CSS Modules 等。其中预处理器和 BEM 都会有的一个问题就是样式覆盖。而 CSS Modules 则是通过 JS 来管理依赖，最大化的结合了 JS 模块化和 CSS 生态，比如 Vue 中的 style scoped。
资源模块化：任何资源都能以模块的形式进行加载，目前大部分项目中的文件、CSS、图片等都能直接通过 JS 做统一的依赖关系处理。

#### 3.2、组件化

不同于模块化，模块化是对文件、对代码和资源拆分，而组件化则是对 UI 层面的拆分。

通常，我们会需要对页面进行拆分，将其拆分成一个一个的零件，然后分别去实现这一个个零件，最后再进行组装。 在我们的实际业务开发中，对于组件的拆分我们需要做不同程度的考量，其中主要包括细粒度和通用性这两块的考虑。 对于业务组件，你更多需要考量的是针对你负责业务线的一个适用度，即你设计的业务组件是否成为你当前业务的 “通用” 组件。

#### 3.3、规范

正所谓无规矩不成方圆，一些好的规范则能很好的帮助我们对项目进行良好的开发管理。规范化指的是我们在工程开发初期以及开发期间制定的系列规范，其中又包含了

项目目录结构
编码规范：对于编码这块的约束，一般我们都会采用一些强制措施，比如 ESLint、StyleLint 等。
联调规范
文件命名规范
样式管理规范：目前流行的样式管理有 BEM、Sass、Less、Stylus、CSS Modules 等方式。
git flow 工作流：其中包含分支命名规范、代码合并规范等。
定期 code review … 等等

（当一个项目已经使用一种方式写法就不要再改动添加多种写法，让规范结果清晰，避免看起来很乱）

#### 3.4、自动化

从最早先的 grunt、gulp 等，再到目前的 webpack、parcel。这些自动化工具在自动化合并、构建、打包都能为我们节省很多工作。而这些只是前端自动化其中的一部分，前端`自动化`还包含了持续集成、自动化测试等方方面面。



参考推荐：[链接](https://blog.csdn.net/weixin_42402867/article/details/113573501?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164076199516780357262433%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164076199516780357262433&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-113573501.pc_search_em_sort&utm_term=%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96&spm=1018.2226.3001.4187)



### 4、前端架构需要做什么？
仅仅是个人结合一些网络文章的理解
前端架构师的核心工作是降低需求增长带来的技术实现的复杂性
架构就是要把复杂抽象的事简化并运用到实际当中，以便更清晰和易于维护。以及对事物的差异化，共性，优缺点的认知判断，而不是用简单的降低前端开发复杂度来解释


