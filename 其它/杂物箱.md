### ajax

是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。实现页面的局部刷新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。。ajax 的核心是通过 XmlHttpRequest 获取非本页内容

### jsonp

用于解决主流浏览器的跨域数据访问的问题

可以通过JavaScript动态创建script标签的src属性，这样就可以灵活调用远程服务。

利用script标签自身所拥有的属性src，通过src属性下的url来获取外部的js格式的数据。（底层原理）

**创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调。将JSON数据填充进回调函数

实现跨域请求，形成一种非正式传输协议。ajax做不到的，就来帮ajax做（因为ajax必须要域名端口协议都相同）

JSON：是一种基于文本的数据交换方式（不支持跨域），而JSONP是一种非官方跨域数据交互协议。

### jQuery库

提供了强大的元素选择器。提供了对css样式操作的支持。极大的简化了javascript对dom的操作，使用链式方式编写代码。解决了大量浏览器之间的兼容性的问题。简化ajax编程，提供了一种更加简洁，统一的编程方式

优：减少代码量，减少dom的操作，把所有方法都放在一个库里面
缺点:维护性差，jq只是个库，vue是框架,数组与对象的操作

### Bootstrap框架

简洁，直观，强悍的前端开发框架，让开发更迅速简单。主要用于响应式开发。提高开发效率

### get和post

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。   
2. Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。   
3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。   
4. Get执行效率却比Post方法好。Get是form提交的默认方法。

### Node.js

基于 Chrome(谷歌) V8 引擎的JavaScript 运行环境。用于方便地搭建响应速度快、易于扩展的网络应用

单线程

Node可以在不新增额外线程的情况下，依然可以对任务进行并发处理 —— Node.js是单线程的。它通过事件循环（event loop）来实现并发操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。

非阻塞IO

V8虚拟机

事件驱动



### 闭包

就是能够读取其他函数内部变量的函数。闭包是将函数内部和函数外部连接起来的桥梁。
作用： 可以读取函数内部的变量 让这些变量的值始终保持在内存中。

**缺点** 1.闭包的缺点就是会增大内存使用量，并且使用不当容易造成内存泄漏。

2.如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。



### 面向对象（oop）

 把构成问题的各个事务分解成各个对象 ，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式；通过prototype添加 

主要包括：对象、类、数据抽象、继承、动态绑定、数据封装、多态性、消息传递 

多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

多态，是面向对象的程序设计语言最核心的特征。多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法



### 作用域

就是变量与函数的可访问范围。作用域分为 全局作用域(所声明的变量全局都可以访问),局部作用域(所声明的变量只在其内部可以访问)。
作用域链：当我们在一个函数内部访问当前作用域内不存在的变量时，就会逐层向外查找，如果一直找不到就会报错。当我们在局部作用域中，调用外部变量时，就产生了作用域链。

全局变量和局部变量的区别如下：
1. 作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等
2. 内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区
3. 生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了
4. 使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量。



### es5新

json转字符串

新增object接口

新增array数组接口：增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法



### 前端页面构成

结构层 Html 表示层 CSS 行为层 js;



### 原型与原型链 ： op

原型：当定义一个函数数据类型时候，都会自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。
原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中

原型链：通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条。每个对象都会有一个内置 **proto** 对象，当在当前对象中找不到属性的时候就会在其原型链中查找前端的兼容问题

如何决解兼容
兼容css,html，js



### 垃圾回收

垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。如何清空，把变量值赋予一个null就清空了

### less和sass

作用：都是预编译器。可以运算；赋值；颜色功能；作用域；命名空间
区别
Less是基于JavaScript的在客户端处理
Sass是基于ruby在服务器处理
变量在Less和Sass中的唯一区别就是Less用@，Sass用$

### 事件冒泡和捕获

冒泡和捕获是指在元素上的事件被触发的时候，js 传递事件的两种方向，或者说过程。
1.捕获阶段：先由文档的根节点 document 往事件触发对象，从外向内捕获事件对象；
2.定位目标：寻找到目标事件位置（事发地），触发事件；
3.冒泡阶段：再从目标事件位置往文档的根节点方向回溯，从内向外冒泡事件对象。

### 拷贝

浅拷贝：引用数据类型数组对象 保存在**堆内存中** ；包括对象，数组
深拷贝：基本数据类型； 保存在**栈内存** ； 数值、字符串、布尔、null、undefined （值类型） 

浅拷贝后，修改新的拷贝对象，其被拷贝的对象同时也被修改了；深拷贝就很好解决这个问题。

### 堆与栈的关系

栈的特点：栈由系统自动分配，用于存放函数的参数值、局部变量等。开口向上,速度快,容量小。(基本数据类型)都存放在栈区域。存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。通常经常调用。

堆的特点：速度稍慢,容量比较大。(引用数据类型)都存放在堆区域。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收。

1.3 堆与栈区别
堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：
（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。



### promise

Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。

主要用于异步化操作。可以按照期望的顺序来执行，返回符合预期的结果

三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。

特点：1.对象的状态不受外界影响。2.一旦状态改变，就不会再变。



### token

Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库



### 为什么要初始化样式？

由于不同的浏览器的内核不同，而内核都存在一定的差异，所解析出来的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异 。但是初始化 CSS 会对搜索引擎优化造成小影响



### 布局

##### 响应式布局：

1，每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。

响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出满意的效果，通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。

##### 自适应布局：

屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。使用 @media媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。

##### 弹性布局：

1. rem/em区别：rem是相对于html元素的font-size大小而言的，而em是相对于其父元素，1em:16px （手机端最好用弹性布局）
2. 使用 em或 rem单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为em是相对父级元素的原因没有得到推广

##### 流式布局：

流式布局（Liquid）的特点（也叫"Fluid") 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。



#### axios

Axios是一个基于Promise（ES6中用于处理异步的）的HTTP库，用于浏览器和node.js中，API。是用来调用ajax请求的

可以在浏览器中发送 XMLHttpRequests
2、可以在 node.js 发送 http 请求
3、支持 Promise API
4、拦截请求和响应
5、转换请求数据和响应数据
6、能够取消请求
7、自动转换 JSON 数据
8、客户端支持保护安全免受 XSRF 攻击

#### vue-router

（单页应用）的路径管理器 

###### hash模式

hash模式背后的原理是`onhashchange`事件.hash发生变化的url都会被浏览器记录下来，所以前进后退都可以用了

###### history路由

前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由，省略了 #



#### 三大流行框架

React、Vue、Angular

##### vue：

 轻量级的框架 ; 双向数据绑定 ; 指令 ;插件化

 优点 ：  简单  ；快速； 强大 ； 缺点  ： 不支持IE8 ； 没有angular那么成熟 

##### React： 

 声明式设计 ； 高效 ； 灵活 

##### Angular：

 特点1.良好的应用程序结构 ； 2.双向数据绑定 ； 3.指令 ； 4.HTML模板  5.可嵌入、注入和测试 

 优点：模板功能强大丰富 ，比较完善的前端框架 。 缺点 ： angular 入门容易 ，深入难



#### 单页面(SPA)应用程序

优：1.良好的交互体验。单页应用的内容的改变不需要重新加载整个页面，获取数据也是通过Ajax异步获取，没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象，页面显示流畅，web应用更具响应性和更令人着迷。

2.良好的前后端工作分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。

3.减轻服务器的负担。单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍

缺：1.首屏加载慢。如果不对路由进行处理，在加载首页的时候，就会将所有组件全部加载，并向服务器请求数据，这必将拖慢加载速度。通过查看Network，发现整个网站加载试讲长达10几秒，加载时间最长的就是js、css文件和媒体文件及图片

解决：Vue-router懒加载

2.不利于seo。

3.不适合开发大项目，大型项目中可能会涉及大量的DOM操作，大量的路由，组件，操作起来比较繁琐、复杂的动画效果，也就不适合使用Vue、react框架进行开发。

vue如何解决ajax请求的问题



#### jQuery和Vue的区别

vue:vue.js专注于MVVM模型的ViewModel层，通过双向数据绑定把view层和Model层连接起来，通过对数据的操作就可以完成对页面视图的渲染。vue以它独特的优势简单、快速、组合、紧凑、强大而迅速崛起.

 vue基于一种MVVM模式，使用数据驱动的方式，通过Vue对象将数据和View完全分离开来。对数据进行操作，不在需要引用相应的DOM对象，通过vue对象，将数据和相应的DOM对象相互绑定起来

jquery:偏重于对dom的操作. jquery是直接操作DOM；使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作；和原生的js区别只在于可以更方便的选取和操作DOM对象；数据和界面是在一起，比如获取input标签的内容



### 数据或密码加密

使用md5或rsa；sm2；AES



### PWA

PWA的中文名叫做**渐进式网页应用**，早在2014年， W3C 公布过 `Service Worker` 的相关草案，但是其在生产环境被 `Chrome` 支持是在 2015 年。如果我们把 PWA 的关键技术之一 `Service Worker` 的出现作为 `PWA` 的诞生时间，那就应该是 2015 年

`PWA` 不是特指某一项技术，而是应用了多项技术的 `Web App`。其核心技术包括 `App Manifest`、`Service Worker`、`Web Push`，等等



